\section{Step 2: Lattice Cryptography, LWE and RLWE}
\begin{frame}[c]{Lattices}
  \begin{columns}
    \begin{column}{0.32\linewidth}
      \begin{figure}
        \centering
        \scalebox{0.5}{\inputtikz{figures/lattice}}
        % \caption[Illustration of a standard lattice]{
        %   Illustration of a standard lattice $\lat$ with two basis vectors $\vec{b}_1$ and $\vec{b}_2$.
        % }
        \label{fig:lattice}
      \end{figure}
    \end{column}
    \begin{column}{0.6\linewidth}
      \begin{definition}[Lattice]
        A lattice $(\lat, +, \cdot)$ is a vector field over the integers $(\Z, +, \cdot)$, given $n$ basis vectors $\vec{b_1}, \vec{b_2}, ..., \vec{b_n} \in \R^n$, with
        $$\lat := \bigg\{\sum_{i=1}^n c_i \vec{b}_i \,\bigg|\, c \in \Z\bigg\} \subseteq \R^n \,.$$
      \end{definition}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{The \gls{lwe} Problem}
  \begin{definition}[LWE-Distribution $A_{\vec{s}, \chi_{error}}$]
    Given a prime $q \in \N$ and $n \in \N$, choose a secret $\vec{s} \in (\Z / q \Z)^n$.
    Sampling from $A_{\vec{s}, \chi_{error}}$:
    \begin{itemize}
      \item Sample a uniformly random vector $a \in (\Z/q\Z)^n$.
      \item Sample a scalar 'error term' $\mu \in \Z / q \Z$ from $\chi_{error}$.
      \item Compute a noisy inner product $b = \vec{s} \cdot \vec{a} + \mu$.
      \item Output the pair $(\vec{a}, b) \in (\Z / q \Z)^n \times (\Z / q \Z)$.
    \end{itemize}
  \end{definition}

  Search-LWE-Problem:
  Given $m$ independent samples $(\vec{a}_i, b_i)_{0 < i \leq m}$ from $A_{\vec{s}, \chi_{error}}$, find $\vec{s}$.

  Published by \name{Regev} in 2005 \cite{2005-lwe-original}.
  Lead to the \glstext{fhe} scheme by \name{Gentry} in 2009 \cite{2009-gentry-fhe-original}.
\end{frame}

\begin{frame}{What is CKKS?}
  \begin{itemize}
    \item Levelled Homomorphic Encryption Scheme \cite{2017-ckks-original}.
          $$\forall m_1, m_2: \mathcal{E}(m_1) + \mathcal{E}(m_2) = \mathcal{E}(m_1 + m_2) \text{ and } \mathcal{E}(m_1) \cdot \mathcal{E}(m_2) = \mathcal{E}(m_1 \cdot m_2)$$
    \item Enables Public-Key (Asymmetric) Cryptography.
    \item Approximative Floating-Point Arithmetic.
    \item Security based on \glsdesc{lwe}.
    \item \gls{simd} Encoding.
  \end{itemize}
\end{frame}

\begin{frame}{Overview of \gls{ckks}}
  \begin{figure}[H]
    \centering
    \scalebox{0.85}{\inputtikz{figures/ckks-schematic}}
    % \caption[Schematic overview of the CKKS scheme]{
    %   Schematic overview of CKKS \parencite{2017-ckks-original}, adapted from \cite{2020-cryptotree}.
    %   A plain vector $\vec{z} \in \C^{N/2}$ is encoded to $m = \cryptop{CKKS.Encode}(\vec{z})$, encrypted to $\vec{c} = \cryptop{CKKS.Encrypt}(\vec{p}, m)$, decrypted and decoded to a new $\tilde{\vec{z}} = \cryptop{CKKS.Decode}(\cryptop{CKKS.Decrypt}(s, \tilde{\vec{c}}))$.
    % }
    \label{fig:ckks-overview}
  \end{figure}
\end{frame}

\begin{frame}{Encryption and Decryption}
  Public key $\vec{p} = (b, a)$ with $b = -(as + \tilde{\mu})$, secret key $s$, probability distributions $\chi_{enc}$, $\chi_{error}$, plaintext (=message) $m \in R/qR$, ciphertext $\vec{c}$.

  \cryptop{CKKS.} \\
  \begin{tblr}{Q[l,h]Q[l,h,\textwidth - 3.5cm]}
    \cryptop{Encrypt}$(\vec{p}, m)$ & {
        Let $(b,a) = \vec{p}$, $u \leftarrow \chi_{enc}$, $\mu_1, \mu_2 \leftarrow \chi_{error}$,
        then the ciphertext is $\vec{c} = u \cdot \vec{p} + (m + \mu_1, \mu_2) = (m + bu + \mu_1, au + \mu_2)$
        $\quad\rightarrow \vec{c}$} \\
    \cryptop{Decrypt}$(s, \vec{c})$ & {
        Decrypt the ciphertext $\vec{c} = (c_0, c_1)$ as $m = \lbrack c_0 + c_1 s\rbrack_{q_L}$
        $\quad\rightarrow m$} \\
  \end{tblr}
  \begin{itemize}
    \item A public-key cryptosystem! Encrypt with $\vec{p}$, decrypt with $s$.
    \item Leaves the attacker with the \gls{rlwe} problem.
  \end{itemize}
\end{frame}

\begin{frame}{Homomorphic Addition}
  \begin{tblr}{Q[l,h]Q[l,h,\textwidth - 3.5cm]}
    \cryptop{CKKS.Add}$(\vec{c}, \vec{c}')$ & {
        Output $\overline{\vec{c}} = \vec{c} + \vec{c}' = \begin{pmatrix}
            \delta (m + m') + b (u + u') + (\mu_1 + \mu_1') \\
            a (u + u') + (\mu_2 + \mu_2')
          \end{pmatrix}^T$} \\
  \end{tblr}

  Indeed, the ciphertext $\overline{\vec{c}}$ correctly decrypts back to $\overline{m} := m + m'$:
  \begin{align*}
    \cryptop{CKKS.Decrypt}(s, \overline{\vec{c}})
     & = \lfloor \delta\inv [\overline{c_0} + \overline{c_1} s]_t \rceil                                                                                                                                                         \\
     & = \big\lfloor \delta\inv [\delta \overline{m} + b \overline{u} + \overline{\mu_1} + (a \overline{u} + \overline{\mu_2}) s]_t \big\rceil                                                                                   \\
     & = \big\lfloor [(\delta\inv\delta) \overline{m} + \delta\inv b \overline{u} + \delta\inv \overline{\mu_1} + \delta\inv a s \overline{u} + \delta\inv \overline{\mu_2} s]_t \big\rceil                                      \\
     & = \big\lfloor [\overline{m} - \cancel{\delta\inv as \overline{u}} - \delta\inv \tilde{\mu} \overline{u} + \delta\inv \overline{\mu_1} + \cancel{\delta\inv as \overline{u}} + \delta\inv \overline{\mu_2} s]_t \big\rceil \\
     & = \big\lfloor [\overline{m} + \underbrace{\delta\inv (\overline{\mu_1} + \overline{\mu_2} s - \tilde{\mu} \overline{u})}_{:= \epsilon \,, ||\epsilon|| \ll 1}]_t \big\rceil
    \approx \big\lfloor [\overline{m}]_t \big\rceil = \lfloor \overline{m} \rceil \approx \overline{m}
  \end{align*}
\end{frame}
